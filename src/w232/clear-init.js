// Generated by LiveScript 1.4.0
var ref$, sleep, waitFor, timeoutWaitFor, go, isWaiting, merge, unpack, pack, repl, config, debugLog, http, getLogger, i, genReqId, slice$ = [].slice;
ref$ = require('../lib/aea'), sleep = ref$.sleep, waitFor = ref$.waitFor, timeoutWaitFor = ref$.timeoutWaitFor, go = ref$.go, isWaiting = ref$.isWaiting, merge = ref$.merge, unpack = ref$.unpack, pack = ref$.pack, repl = ref$.repl, config = ref$.config, debugLog = ref$.debugLog;
http = require('http');
function alignLeft(width, inp){
  var x;
  return x = (inp + repeatString$(" ", width)).slice(0, width);
}
getLogger = function(src){
  return function(){
    var x;
    x = slice$.call(arguments);
    return debugLog.call(this, alignLeft(15, src + "") + ":" + x.join(''));
  };
};
i = 0;
genReqId = function(digit){
  return i++;
};
function LongPolling(settings){
  this.settings = settings;
  this.content = {
    node: this.settings.id
  };
  this.events = {
    error: [],
    connect: [],
    disconnect: [],
    data: []
  };
  this.connected = false;
  this.connecting = false;
  this.retryCount = 0;
  this.retryInterval = 500;
  this.maxInterval = 5000;
}
LongPolling.prototype.on = function(event, callback){
  var ref$;
  return (ref$ = this.events)[event] = ref$[event].concat(callback);
};
LongPolling.prototype.trigger = function(name){
  var event, i$, x$, ref$, len$, results$ = [];
  event = slice$.call(arguments, 1);
  for (i$ = 0, len$ = (ref$ = this.events[name]).length; i$ < len$; ++i$) {
    x$ = ref$[i$];
    if (typeof x$ === 'function') {
      results$.push(x$.apply(this, event));
    }
  }
  return results$;
};
LongPolling.prototype.send = function(msg, callback){
  var log, e;
  log = getLogger('SEND');
  try {
    if (!this.connected) {
      throw 'you MUST connect first!';
    }
    return this.postRaw({
      data: msg
    }, callback);
  } catch (e$) {
    e = e$;
    log("error: ", e);
    return this.commErr(e, callback);
  }
};
LongPolling.prototype.getRaw = function(){
  var i$, params, callback, query, path, __, log, queryStr, key, value, err;
  params = 0 < (i$ = arguments.length - 1) ? slice$.call(arguments, 0, i$) : (i$ = 0, []), callback = arguments[i$];
  query = params[0];
  path = params[1] || this.settings.sociPath;
  __ = this;
  log = getLogger('GET_RAW');
  try {
    queryStr = "?" + (function(){
      var ref$, results$ = [];
      for (key in ref$ = query) {
        value = ref$[key];
        results$.push(key + "=" + value);
      }
      return results$;
    }()).join("&");
    if (query != null) {
      log("query string: ", queryStr);
    }
    return sleep(0, function(){
      var options, requestId, req;
      options = {
        host: __.settings.host,
        port: __.settings.port,
        method: 'GET',
        path: path + queryStr
      };
      requestId = genReqId(3);
      req = http.get(options, function(res){
        res.on('data', function(data){
          var e;
          log("got raw data: ", data);
          try {
            return callback(null, unpack(data));
          } catch (e$) {
            e = e$;
            return callback({
              exception: e,
              message: data
            }, null);
          }
        });
        res.on('error', function(){
          log("res error: ", err);
          throw null;
        });
        return res.on('close', function(){
          log(requestId + " request is closed by server... ");
          throw null;
        });
      });
      return req.on('error', function(err){
        log("req error: ", err);
        return __.commErr(err, callback);
      });
    });
  } catch (e$) {
    err = e$;
    log("get-raw returned with error: ", err);
    return __.commErr(err, callback);
  }
};
LongPolling.prototype.commErr = function(reason, callback){
  var log;
  log = getLogger('COMM_ERR');
  log("comm error happened: ", reason);
  log("connected: ", this.connected);
  log("connecting: ", this.connecting);
  callback(reason, null);
  if (this.connected) {
    this.trigger('error', reason);
    this.trigger('disconnect');
    this.connected = false;
  }
  if (this.connecting) {
    return log("Already trying to reconnect!...");
  } else {
    log("Triggering connect!");
    return this.connect();
  }
};
LongPolling.prototype.postRaw = function(msg, callback){
  var __, log, err, content, contentStr, options, requestId, req;
  __ = this;
  log = getLogger("POST_RAW");
  try {
    if (!this.connected) {
      throw 'not connected';
    }
    err = false;
    content = merge(this.content, msg);
    contentStr = pack(content);
    options = {
      host: this.settings.host,
      port: this.settings.port,
      method: 'POST',
      path: this.settings.sicoPath,
      headers: {
        "Content-Type": "application/json",
        "Content-Length": contentStr.length
      }
    };
    requestId = genReqId(3);
    log("initiating new request: ", requestId);
    req = http.request(options, function(res){
      res.on('data', function(data){
        var e;
        log("got data: ", data);
        try {
          return callback(null, unpack(data));
        } catch (e$) {
          e = e$;
          log("CAN NOT UNPACK DATA: ", data);
          log("err: ", e);
          return callback(e, null);
        }
      });
      res.on('error', function(){
        log(requestId + " Response Error: ", err);
        throw "RES.ON ERROR???";
      });
      return res.on('close', function(){
        log(requestId + " request is closed by server... ");
        throw "RES.ON CLOSE???";
      });
    });
    req.on('error', function(err){
      log(requestId + " Request Error: ", err);
      return __.commErr(err, callback);
    });
    req.write(contentStr);
    return req.end();
  } catch (e$) {
    err = e$;
    log("raw-get has exception: ", err);
    return __.commErr(err, callback);
  }
};
LongPolling.prototype.connect = function(nextStep){
  var __, log, interval;
  __ = this;
  log = getLogger('CONNECT');
  this.connecting = true;
  interval = this.retryCount * this.retryInterval;
  if (interval > this.maxInterval) {
    interval = this.maxInterval;
  }
  this.retryCount++;
  if (interval > 0) {
    log("retrying in " + interval + "ms...");
  }
  return sleep(interval, function(){
    log("Trying to connect to server...");
    return __.getRaw({
      protocol: "aea-longpolling-01"
    }, '/_info', function(err, data){
      var e;
      try {
        if (err) {
          throw "connection error";
        }
        if (data.ack !== 'OK') {
          throw "not my server!";
        }
        log("Connection seems ok, starting all tasks...");
        return sleep(0, function(){
          __.retryCount = 0;
          __.connected = true;
          __.connecting = false;
          __.receiveLoop();
          __.trigger('connect', data);
          if (typeof nextStep === 'function') {
            return nextStep();
          }
        });
      } catch (e$) {
        e = e$;
        log("Error: ", e);
        return sleep(10, function(){
          __.connecting = false;
          return __.connect();
        });
      }
    });
  });
};
LongPolling.prototype.receiveLoop = function(){
  var __, log;
  __ = this;
  log = getLogger('RECEIVE_LOOP');
  log("started...");
  return function lo(op){
    var receiverId;
    receiverId = genReqId(3);
    return __.getRaw(function(err, res){
      if (err) {
        log("stopping receive loop: ", err);
        return op();
      } else {
        log("got data: ", pack(res));
        __.trigger('data', res);
        return lo(op);
      }
    });
  }(function(){});
};
function init(){
  var log, comm, x$;
  log = getLogger('MAIN');
  comm = new LongPolling({
    host: 'localhost',
    port: 5656,
    sicoPath: '/send',
    sociPath: '/receive',
    id: 'abc123'
  });
  x$ = comm;
  x$.on('error', function(err){
    return log("COMM-ERR:: ", err);
  });
  x$.on('connect', function(info){
    return log("Connected to server. Server info: ", pack(info));
  });
  x$.on('disconnect', function(){
    return log("Disconnected from server!!!");
  });
  x$.on('data', function(data){
    return log("Received DATA: ", pack(data));
  });
  return comm.send({
    mydata: 'hello'
  }, function(err){
    log("send hello: ", err);
    return comm.connect(function(){
      log("it seems connection is ok, continuing...");
      return function lo(op){
        return;
        return comm.send({
          temperature: Math.random()
        }, function(err){
          if (err) {
            log("We couldn't send to data because: ", err);
          }
          return timeoutWaitFor(10000, 'temperature-measured', function(){
            return lo(op);
          });
        });
      }(function(){});
    });
  });
} init();
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}